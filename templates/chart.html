<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê³ ê¸‰ ì°¨íŠ¸ ë¶„ì„ ë„êµ¬ (ìì„ ê¸°ëŠ¥)</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        .container {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
        }
        .header {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
        }
        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .tool-group {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .btn {
            padding: 10px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: rgba(255,255,255,0.9);
            color: #2c3e50;
            border: 1px solid rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .btn:hover {
            background: rgba(255,255,255,1);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        .btn.magnet {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            position: relative;
        }
        .btn.magnet::after {
            content: '';
            position: absolute;
            top: 2px; right: 2px;
            width: 8px; height: 8px;
            background: #f39c12;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }
        #chartDiv {
            flex-grow: 1;
            background: rgba(255,255,255,0.95);
            margin: 10px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .status-bar {
            padding: 8px 20px;
            background: rgba(255,255,255,0.9);
            border-top: 1px solid rgba(0,0,0,0.1);
            font-size: 0.85rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .magnet-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid #e74c3c;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.2);
            pointer-events: none;
            z-index: 1000;
            display: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">ì°¨íŠ¸ ë¶„ì„ ë„êµ¬</h1>
            <div class="toolbar">
                <div class="tool-group">
                    <button id="magnetBtn" class="btn magnet active" title="ìì„ ê¸°ëŠ¥ (ìº”ë“¤ì— ìë™ ë¶™ê¸°)">
                        <i class="fas fa-magnet"></i> ìì„
                    </button>
                </div>

                <div class="tool-group">
                    <button id="tool-trendline" class="btn tool-btn" title="ì¶”ì„¸ì„ "><i class="fas fa-chart-line"></i> ì¶”ì„¸ì„ </button>
                    <button id="tool-horizontal" class="btn tool-btn" title="ìˆ˜í‰ì„ "><i class="fas fa-minus"></i> ìˆ˜í‰ì„ </button>
                    <button id="tool-vertical" class="btn tool-btn" title="ìˆ˜ì§ì„ "><i class="fas fa-grip-lines-vertical"></i> ìˆ˜ì§ì„ </button>
                </div>

                <div class="tool-group">
                    <button id="tool-fibonacci" class="btn tool-btn" title="í”¼ë³´ë‚˜ì¹˜ ë˜ëŒë¦¼"><i class="fas fa-wave-square"></i> í”¼ë³´ë‚˜ì¹˜</button>
                    <button id="tool-fibonacci-ext" class="btn tool-btn" title="í”¼ë³´ë‚˜ì¹˜ í™•ì¥"><i class="fas fa-expand-arrows-alt"></i> í”¼ë³´ í™•ì¥</button>
                </div>

                <div class="tool-group">
                    <button id="tool-rectangle" class="btn tool-btn" title="ì‚¬ê°í˜•"><i class="fas fa-square"></i> ì‚¬ê°í˜•</button>
                    <button id="tool-channel" class="btn tool-btn" title="ì±„ë„"><i class="fas fa-arrows-alt-v"></i> ì±„ë„</button>
                </div>

                <div class="tool-group">
                    <button id="tool-text" class="btn tool-btn" title="í…ìŠ¤íŠ¸"><i class="fas fa-font"></i> í…ìŠ¤íŠ¸</button>
                    <button id="tool-arrow" class="btn tool-btn" title="í™”ì‚´í‘œ"><i class="fas fa-arrow-right"></i> í™”ì‚´í‘œ</button>
                </div>

                <div class="tool-group">
                    <button id="undoBtn" class="btn" title="ë˜ëŒë¦¬ê¸°"><i class="fas fa-undo"></i> ë˜ëŒë¦¬ê¸°</button>
                    <button id="clearBtn" class="btn danger" title="ëª¨ë‘ ì§€ìš°ê¸°"><i class="fas fa-trash"></i> ì§€ìš°ê¸°</button>
                </div>
            </div>
        </div>

        <div id="chartDiv"></div>

        <div class="status-bar">
            <div id="coordinates">ë§ˆìš°ìŠ¤ë¥¼ ì°¨íŠ¸ì— ì˜¬ë ¤ë³´ì„¸ìš”</div>
            <div id="tool-status">ë„êµ¬ë¥¼ ì„ íƒí•˜ì—¬ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”</div>
        </div>
    </div>

    <div class="magnet-indicator" id="magnetIndicator"></div>

    <script>
        // ìƒ˜í”Œ ë°ì´í„° ìƒì„±
        function generateSampleData() {
            const dates = [];
            const open = [], high = [], low = [], close = [];
            const portfolio = [], benchmark = [];

            let basePrice = 100 + Math.random() * 20;
            let portfolioValue = 100;
            let benchmarkValue = 100;
            const today = new Date();

            for (let i = 199; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                dates.push(date.toISOString().split('T')[0]);

                const change = (Math.random() - 0.48) * 6; // Slightly positive bias
                const openPrice = basePrice;
                const closePrice = basePrice + change;
                const highPrice = Math.max(openPrice, closePrice) + Math.random() * 3;
                const lowPrice = Math.min(openPrice, closePrice) - Math.random() * 3;

                open.push(openPrice);
                high.push(highPrice);
                low.push(lowPrice);
                close.push(closePrice);

                basePrice = closePrice > 0 ? closePrice : 1;

                const aiReturn = change * (1 + Math.random() * 0.3);
                const bhReturn = change;

                portfolioValue *= (1 + aiReturn / 100);
                benchmarkValue *= (1 + bhReturn / 100);

                portfolio.push(portfolioValue);
                benchmark.push(benchmarkValue);
            }

            return { dates, open, high, low, close, portfolio, benchmark };
        }

        const chartDiv = document.getElementById('chartDiv');
        const chartData = generateSampleData();

        // ì°¨íŠ¸ ë°ì´í„° ì„¤ì •
        const candlestickTrace = {
            x: chartData.dates,
            open: chartData.open,
            high: chartData.high,
            low: chartData.low,
            close: chartData.close,
            type: 'candlestick',
            name: 'ì£¼ê°€',
            xaxis: 'x',
            yaxis: 'y1'
        };

        const portfolioTrace = {
            x: chartData.dates,
            y: chartData.portfolio,
            type: 'scatter',
            mode: 'lines',
            name: 'AI ì „ëµ',
            line: { color: '#667eea', width: 2 },
            xaxis: 'x',
            yaxis: 'y2'
        };

        const benchmarkTrace = {
            x: chartData.dates,
            y: chartData.benchmark,
            type: 'scatter',
            mode: 'lines',
            name: 'ë²¤ì¹˜ë§ˆí¬',
            line: { color: '#f5a623', width: 2 },
            xaxis: 'x',
            yaxis: 'y2'
        };

        const layout = {
            title: {
                text: 'ì°¨íŠ¸ë¶„ì„',
                font: { size: 20, color: '#2c3e50' }
            },
            xaxis: {
                domain: [0, 1],
                anchor: 'y2',
                rangeslider: { visible: false },
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)'
            },
            yaxis: {
                domain: [0.3, 1],
                title: 'ì£¼ê°€',
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)'
            },
            yaxis2: {
                domain: [0, 0.25],
                title: 'í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜',
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)'
            },
            shapes: [],
            annotations: [],
            dragmode: 'pan',
            plot_bgcolor: 'rgba(255,255,255,0.9)',
            paper_bgcolor: 'rgba(255,255,255,0.9)',
            margin: { t: 50, b: 50, l: 60, r: 60 }
        };

        const data = [candlestickTrace, portfolioTrace, benchmarkTrace];

        Plotly.newPlot('chartDiv', data, layout, {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d']
        });

        // --- ë¶„ì„ ë„êµ¬ ë° ìì„ ê¸°ëŠ¥ ì‹œìŠ¤í…œ ---
        let magnetEnabled = true;
        let currentTool = null;
        let drawingIdCounter = 0;
        let relayoutTimeout = null;

        const magnetBtn = document.getElementById('magnetBtn');
        const toolButtons = document.querySelectorAll('.tool-btn');
        const undoBtn = document.getElementById('undoBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusElement = document.getElementById('tool-status');
        const coordinatesElement = document.getElementById('coordinates');

        const fiboLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
        const fiboExtLevels = [1, 1.236, 1.382, 1.5, 1.618, 2, 2.618];
        const fiboColors = ['#787878', '#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#FFD700'];

        magnetBtn.addEventListener('click', () => {
            magnetEnabled = !magnetEnabled;
            magnetBtn.classList.toggle('active', magnetEnabled);
            updateStatus();
        });

        function findNearestCandlePoint(x, y) {
            if (!chartData || chartData.dates.length === 0) return { x, y, snapped: false };
            let closestDateIndex = 0;
            let minDistance = Infinity;
            chartData.dates.forEach((date, index) => {
                const distance = Math.abs(new Date(x).getTime() - new Date(date).getTime());
                if (distance < minDistance) {
                    minDistance = distance;
                    closestDateIndex = index;
                }
            });

            const ohlcPrices = [chartData.open[closestDateIndex], chartData.high[closestDateIndex], chartData.low[closestDateIndex], chartData.close[closestDateIndex]];
            let closestPrice = ohlcPrices[0];
            let minPriceDistance = Math.abs(closestPrice - y);

            ohlcPrices.forEach(price => {
                const distance = Math.abs(price - y);
                if (distance < minPriceDistance) {
                    minPriceDistance = distance;
                    closestPrice = price;
                }
            });

            return { x: chartData.dates[closestDateIndex], y: closestPrice, snapped: true };
        }

        function setActiveTool(toolName) {
            currentTool = (currentTool === toolName) ? null : toolName;
            toolButtons.forEach(btn => btn.classList.toggle('active', btn.id === `tool-${currentTool}`));
            let dragmode = 'pan';
            if (['trendline', 'horizontal', 'vertical', 'arrow'].includes(currentTool)) dragmode = 'drawline';
            else if (['rectangle', 'fibonacci', 'fibonacci-ext', 'channel'].includes(currentTool)) dragmode = 'drawrect';
            layout.dragmode = dragmode;
            Plotly.relayout('chartDiv', { dragmode: dragmode });
            updateStatus();
        }

        function updateStatus() {
            const magnetStatus = magnetEnabled ? ' (ğŸ§² ìì„ ON)' : ' (ìì„ OFF)';
            const messages = { null: 'ë„êµ¬ë¥¼ ì„ íƒí•˜ì—¬ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”' + magnetStatus, 'trendline': 'ë‘ ì ì„ í´ë¦­í•˜ì—¬ ì¶”ì„¸ì„ ì„ ê·¸ìœ¼ì„¸ìš”' + magnetStatus, 'horizontal': 'ìˆ˜í‰ì„ ì„ ê·¸ì„ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”' + magnetStatus, 'vertical': 'ìˆ˜ì§ì„ ì„ ê·¸ì„ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”' + magnetStatus, 'fibonacci': 'ë“œë˜ê·¸í•˜ì—¬ í”¼ë³´ë‚˜ì¹˜ ë˜ëŒë¦¼ ì˜ì—­ì„ ì„¤ì •í•˜ì„¸ìš”' + magnetStatus, 'fibonacci-ext': 'ë“œë˜ê·¸í•˜ì—¬ í”¼ë³´ë‚˜ì¹˜ í™•ì¥ ì˜ì—­ì„ ì„¤ì •í•˜ì„¸ìš”' + magnetStatus, 'rectangle': 'ë“œë˜ê·¸í•˜ì—¬ ì‚¬ê°í˜•ì„ ê·¸ìœ¼ì„¸ìš”' + magnetStatus, 'channel': 'ë“œë˜ê·¸í•˜ì—¬ ì±„ë„ì„ ì„¤ì •í•˜ì„¸ìš”' + magnetStatus, 'text': 'í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•  ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”' + magnetStatus, 'arrow': 'ë“œë˜ê·¸í•˜ì—¬ í™”ì‚´í‘œë¥¼ ê·¸ìœ¼ì„¸ìš”' + magnetStatus };
            statusElement.textContent = messages[currentTool] || messages.null;
        }

        toolButtons.forEach(btn => btn.addEventListener('click', () => setActiveTool(btn.id.split('-').slice(1).join('-'))));
        clearBtn.addEventListener('click', () => {
            layout.shapes = [];
            layout.annotations = [];
            Plotly.react('chartDiv', data, layout);
        });
        undoBtn.addEventListener('click', () => {
            const lastDrawingIdNum = Math.max(0, ...layout.shapes.map(s => parseInt(s.drawing_id?.split('-')[1] || 0)), ...layout.annotations.map(a => parseInt(a.drawing_id?.split('-')[1] || 0)));
            if (lastDrawingIdNum > 0) {
                const drawingId = `drawing-${lastDrawingIdNum}`;
                layout.shapes = layout.shapes.filter(s => s.drawing_id !== drawingId);
                layout.annotations = layout.annotations.filter(a => a.drawing_id !== drawingId);
            } else {
                if (layout.shapes.length > 0) layout.shapes.pop();
                else if (layout.annotations.length > 0) layout.annotations.pop();
            }
            Plotly.react('chartDiv', data, layout);
        });

        function createFibonacciRetracement(rect, drawingId) {
            const y_start = Math.min(rect.y0, rect.y1);
            const y_end = Math.max(rect.y0, rect.y1);
            const y_diff = y_end - y_start;
            const descending = rect.y0 > rect.y1;

            fiboLevels.forEach((level, i) => {
                const level_y = descending ? y_end - y_diff * level : y_start + y_diff * level;
                layout.shapes.push({ type: 'line', x0: rect.x0, y0: level_y, x1: rect.x1, y1: level_y, line: { color: fiboColors[i % fiboColors.length], width: 1, dash: level === 0 || level === 1 ? 'solid' : 'dot' }, name: 'fib_line', drawing_id: drawingId, editable: false });
                layout.annotations.push({ x: rect.x1, y: level_y, text: `${(level * 100).toFixed(1)}% (${level_y.toFixed(2)})`, showarrow: false, font: { color: fiboColors[i % fiboColors.length], size: 10 }, xanchor: 'left', yanchor: 'middle', name: 'fib_annotation', drawing_id: drawingId });
            });
        }

        function createFibonacciExtension(rect, drawingId) {
            const y_start = Math.min(rect.y0, rect.y1);
            const y_end = Math.max(rect.y0, rect.y1);
            const y_diff = y_end - y_start;
            const descending = rect.y0 > rect.y1;

            fiboExtLevels.forEach((level, i) => {
                const level_y = descending ? y_end - y_diff * level : y_start + y_diff * level;
                layout.shapes.push({ type: 'line', x0: rect.x0, y0: level_y, x1: rect.x1, y1: level_y, line: { color: fiboColors[i % fiboColors.length], width: 1, dash: 'dash' }, name: 'fib_ext_line', drawing_id: drawingId, editable: false });
                layout.annotations.push({ x: rect.x1, y: level_y, text: `${(level * 100).toFixed(1)}% (${level_y.toFixed(2)})`, showarrow: false, font: { color: fiboColors[i % fiboColors.length], size: 10 }, xanchor: 'left', yanchor: 'middle', name: 'fib_ext_annotation', drawing_id: drawingId });
            });
        }
        
        function createChannel(rect, drawingId) {
            const y_diff = rect.y1 - rect.y0;
            layout.shapes.push({ type: 'line', x0: rect.x0, y0: rect.y1, x1: rect.x1, y1: rect.y1, line: { color: '#0066cc', width: 2 }, name: 'channel_top', drawing_id: drawingId, editable: true });
            layout.shapes.push({ type: 'line', x0: rect.x0, y0: rect.y0, x1: rect.x1, y1: rect.y0, line: { color: '#0066cc', width: 2 }, name: 'channel_bottom', drawing_id: drawingId, editable: true });
            const mid_y = rect.y0 + y_diff / 2;
            layout.shapes.push({ type: 'line', x0: rect.x0, y0: mid_y, x1: rect.x1, y1: mid_y, name: 'channel_mid', drawing_id: drawingId, editable: false });
        }

        chartDiv.on('plotly_relayout', (eventData) => {
            clearTimeout(relayoutTimeout);

            // Case 1: A new shape is being drawn (a tool is active)
            if (currentTool) {
                const lastShape = layout.shapes[layout.shapes.length - 1];
                if (!lastShape) return;

                const drawingId = `drawing-${drawingIdCounter++}`;

                if (magnetEnabled) {
                    const snappedStart = findNearestCandlePoint(lastShape.x0, lastShape.y0);
                    const snappedEnd = findNearestCandlePoint(lastShape.x1, lastShape.y1);
                    lastShape.x0 = snappedStart.x; lastShape.y0 = snappedStart.y;
                    lastShape.x1 = snappedEnd.x; lastShape.y1 = snappedEnd.y;
                }

                lastShape.drawing_id = drawingId;
                lastShape.editable = true;

                switch(currentTool) {
                    case 'trendline': lastShape.name = 'trendline'; lastShape.line = { color: '#0066cc', width: 2 }; break;
                    case 'horizontal': lastShape.name = 'horizontal'; lastShape.y1 = lastShape.y0; lastShape.line = { color: '#ff6b6b', width: 2 }; break;
                    case 'vertical': lastShape.name = 'vertical'; lastShape.x1 = lastShape.x0; lastShape.line = { color: '#4ecdc4', width: 2 }; break;
                    case 'rectangle': lastShape.name = 'rectangle'; lastShape.line = { color: '#45b7d1', width: 2 }; lastShape.fillcolor = 'rgba(69, 183, 209, 0.1)'; break;
                    case 'fibonacci':
                        lastShape.name = 'fib_bg';
                        lastShape.fillcolor = 'rgba(102, 126, 234, 0.1)';
                        lastShape.line = { width: 0 };
                        createFibonacciRetracement(lastShape, drawingId);
                        break;
                    case 'fibonacci-ext':
                        lastShape.name = 'fib_ext_bg';
                        lastShape.fillcolor = 'rgba(255, 107, 107, 0.1)';
                        lastShape.line = { width: 0 };
                        createFibonacciExtension(lastShape, drawingId);
                        break;
                    case 'channel':
                        lastShape.name = 'channel_bg';
                        lastShape.fillcolor = 'rgba(0, 102, 204, 0.05)';
                        lastShape.line = { width: 0 };
                        createChannel(lastShape, drawingId);
                        break;
                    case 'arrow':
                        lastShape.name = 'arrow';
                        lastShape.line = { color: '#e74c3c', width: 3 };
                        layout.annotations.push({ x: lastShape.x1, y: lastShape.y1, text: 'â–¶', showarrow: false, font: { size: 16, color: '#e74c3c' }, name: 'arrow_head', drawing_id: drawingId });
                        break;
                }
                setActiveTool(currentTool); // Deactivate tool
                Plotly.react('chartDiv', data, layout);

            } 
            // Case 2: An existing shape is being edited (no tool is active)
            else if (Object.keys(eventData).some(k => k.startsWith('shapes['))) {
                relayoutTimeout = setTimeout(() => {
                    const shapeKey = Object.keys(eventData).find(k => k.startsWith('shapes['));
                    if (!shapeKey) return;
                    const shapeIndex = parseInt(shapeKey.match(/\d+/)[0]);
                    const editedShape = layout.shapes[shapeIndex];

                    if (editedShape && editedShape.editable) {
                        if (magnetEnabled) {
                            const snappedStart = findNearestCandlePoint(editedShape.x0, editedShape.y0);
                            const snappedEnd = findNearestCandlePoint(editedShape.x1, editedShape.y1);
                            editedShape.x0 = snappedStart.x; editedShape.y0 = snappedStart.y;
                            editedShape.x1 = snappedEnd.x; editedShape.y1 = snappedEnd.y;
                        }

                        if (editedShape.name === 'fib_bg') {
                            layout.shapes = layout.shapes.filter(s => s.drawing_id !== editedShape.drawing_id || s.name === 'fib_bg');
                            layout.annotations = layout.annotations.filter(a => a.drawing_id !== editedShape.drawing_id);
                            createFibonacciRetracement(editedShape, editedShape.drawing_id);
                        }
                        else if (editedShape.name === 'fib_ext_bg') {
                            layout.shapes = layout.shapes.filter(s => s.drawing_id !== editedShape.drawing_id || s.name === 'fib_ext_bg');
                            layout.annotations = layout.annotations.filter(a => a.drawing_id !== editedShape.drawing_id);
                            createFibonacciExtension(editedShape, editedShape.drawing_id);
                        }
                        Plotly.react('chartDiv', data, layout);
                    }
                }, 150); // 150ms delay for snap-on-release
            }
        });

        chartDiv.on('plotly_hover', (eventData) => {
            const point = eventData.points[0];
            const priceText = point.close !== undefined ? `O:${point.open.toFixed(2)} H:${point.high.toFixed(2)} L:${point.low.toFixed(2)} C:${point.close.toFixed(2)}` : (point.y !== undefined ? point.y.toFixed(2) : '');
            coordinatesElement.innerHTML = `<strong>ë‚ ì§œ:</strong> ${point.x} | <strong>ê°€ê²©:</strong> ${priceText}`;
        });

        chartDiv.on('plotly_unhover', () => { coordinatesElement.innerHTML = 'ë§ˆìš°ìŠ¤ë¥¼ ì°¨íŠ¸ì— ì˜¬ë ¤ë³´ì„¸ìš”'; });

        chartDiv.on('plotly_click', (eventData) => {
            if (currentTool === 'text' && eventData.points.length > 0) {
                let point = eventData.points[0];
                if (magnetEnabled) {
                    const snapped = findNearestCandlePoint(point.x, point.y);
                    if (snapped.snapped) point = { x: snapped.x, y: snapped.y };
                }
                const text = prompt('ì¶”ê°€í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:', 'ë¶„ì„ ë©”ëª¨');
                if (text) {
                    const drawingId = `drawing-${drawingIdCounter++}`;
                    layout.annotations.push({ x: point.x, y: point.y, text: text, showarrow: true, arrowhead: 2, arrowsize: 1, arrowwidth: 2, arrowcolor: '#667eea', font: { size: 12, color: '#2c3e50', family: 'Arial Black' }, bgcolor: 'rgba(255,255,255,0.8)', bordercolor: '#667eea', borderwidth: 2, borderpad: 4, name: 'text_annotation', drawing_id: drawingId, editable: true });
                    setActiveTool(currentTool);
                    Plotly.react('chartDiv', data, layout);
                }
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undoBtn.click(); }
                if (e.key === 'm') { e.preventDefault(); magnetBtn.click(); }
            }
            if (e.key === 'Escape') setActiveTool(null);
        });

        updateStatus();
        window.addEventListener('resize', () => Plotly.Plots.resize(chartDiv));
    </script>
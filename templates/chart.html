.header { 
            padding: 15px 20px; 
            background: rgba(255, 255, 255, 0.95); 
            border-bottom: 1px solid rgba(0,0,0,0.1); 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            gap: 10px;
        }
        .title { 
            font-size: 1.6rem; 
            font-weight: 700; 
            color: #2c3e50; 
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .ai-recommendation {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            animation: pulse-glow 2s infinite;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(231, 76, 60, 0.3); }
            50% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.6); }
        }
        .toolbar { 
            display: flex; 
            gap: 8px; 
            flex-wrap: wrap;
            align-items: center;
        }
        .tool-group { 
            display: flex; 
            gap: 4px; 
            padding: 4px; 
            background: rgba(255,255,255,0.8); 
            border-radius: 10px; 
            border: 1px solid rgba(0,0,0,0.1);
        }
        .btn { 
            padding: 8px 12px; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 0.85rem; 
            font-weight: 600; 
            transition: all 0.3s ease;
            display: inline-flex; 
            align-items: center; 
            justify-content: center; 
            gap: 4px; 
            background: rgba(255,255,255,0.9);
            color: #2c3e50;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .btn:hover { 
            background: rgba(255,255,255,1);
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        .btn.active { 
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white; 
            box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
        }
        .btn.magnet { 
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }
        .btn.danger { 
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            gap: 15px;
            padding: 15px;
            min-height: 0;
        }
        
        .chart-container {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        #chartDiv { 
            flex: 1;
            min-height: 500px;
        }
        
        .sidebar {
            flex: 0 0 350px;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }
        
        .performance-dashboard {
            padding: 20px;
        }
        
        .dashboard-header {
            font-size: 1.3rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .metric-label {
            font-size: 0.85rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .positive { color: #27ae60; }
        .negative { color: #e74c3c; }
        .neutral { color: #f39c12; }
        
        .trades-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
        
        .trades-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .trade-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid;
        }
        
        .trade-buy { border-left-color: #27ae60; }
        .trade-sell { border-left-color: #e74c3c; }
        
        .trade-date {
            font-size: 0.8rem;
            color: #6c757d;
            margin-bottom: 4px;
        }
        
        .trade-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .trade-type {
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .trade-price {
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }
        
        .status-bar { 
            padding: 10px 20px; 
            background: rgba(255,255,255,0.9); 
            border-top: 1px solid rgba(0,0,0,0.1); 
            font-size: 0.85rem; 
            color: #666; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                flex: none;
                max-height: 400px;
            }
            .metric-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }
            .toolbar {
                justify-content: center;
            }
            .title {
                justify-content: center;
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">
                <i class="fas fa-robot"></i>
                <span id="chartTitle">AI Ï£ºÏãù Í±∞Îûò Î∂ÑÏÑù</span>
                <div id="aiRecommendation" class="ai-recommendation" style="display:none;">
                    <i class="fas fa-brain"></i>
                    <span id="recommendationText">Ïò§ÎäòÏùò AI Ï∂îÏ≤ú: Î≥¥Ïú†</span>
                </div>
            </div>
            <div class="toolbar">
                <div class="tool-group">
                    <button id="toggleAIBtn" class="btn active" title="AI Î∂ÑÏÑù ÌëúÏãú/Ïà®Í∏∞Í∏∞">
                        <i class="fas fa-robot"></i> AI Î∂ÑÏÑù
                    </button>
                    <button id="toggleSidebarBtn" class="btn active" title="ÏÑ±Í≥º ÎåÄÏãúÎ≥¥Îìú ÌëúÏãú/Ïà®Í∏∞Í∏∞">
                        <i class="fas fa-chart-bar"></i> ÏÑ±Í≥º
                    </button>
                </div>
                
                <div class="tool-group">
                    <button class="btn range-btn" data-range="1m">1M</button>
                    <button class="btn range-btn" data-range="3m">3M</button>
                    <button class="btn range-btn" data-range="6m">6M</button>
                    <button class="btn range-btn" data-range="1y">1Y</button>
                    <button class="btn range-btn active" data-range="all">All</button>
                </div>
                
                <div class="tool-group">
                    <button id="magnetBtn" class="btn magnet active" title="ÏûêÏÑù Í∏∞Îä•">
                        <i class="fas fa-magnet"></i> ÏûêÏÑù
                    </button>
                </div>
                
                <div class="tool-group">
                    <button id="tool-trendline" class="btn tool-btn" title="Ï∂îÏÑ∏ÏÑ†">
                        <i class="fas fa-chart-line"></i> Ï∂îÏÑ∏ÏÑ†
                    </button>
                    <button id="tool-horizontal" class="btn tool-btn" title="ÏàòÌèâÏÑ†">
                        <i class="fas fa-minus"></i> ÏàòÌèâÏÑ†
                    </button>
                    <button id="tool-fibonacci" class="btn tool-btn" title="ÌîºÎ≥¥ÎÇòÏπò">
                        <i class="fas fa-wave-square"></i> ÌîºÎ≥¥ÎÇòÏπò
                    </button>
                </div>
                
                <div class="tool-group">
                    <button id="undoBtn" class="btn" title="ÎêòÎèåÎ¶¨Í∏∞">
                        <i class="fas fa-undo"></i>
                    </button>
                    <button id="clearBtn" class="btn danger" title="Î™®Îëê ÏßÄÏö∞Í∏∞">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="chart-container">
                <div id="chartDiv"></div>
            </div>
            
            <div class="sidebar" id="sidebar">
                <div class="performance-dashboard">
                    <div class="dashboard-header">
                        <i class="fas fa-chart-bar"></i>
                        ÏÑ±Í≥º ÎåÄÏãúÎ≥¥Îìú
                    </div>
                    
                    <div class="metric-grid" id="metricsGrid">
                        <!-- ÏÑ±Í≥º ÏßÄÌëúÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎê©ÎãàÎã§ -->
                    </div>
                    
                    <div class="trades-section">
                        <div class="trades-header">
                            <i class="fas fa-exchange-alt"></i>
                            ÏµúÍ∑º Í±∞Îûò ÎÇ¥Ïó≠
                        </div>
                        <div id="tradesContainer">
                            <!-- Í±∞Îûò ÎÇ¥Ïó≠Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎê©ÎãàÎã§ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div id="coordinates">ÎßàÏö∞Ïä§Î•º Ï∞®Ìä∏Ïóê Ïò¨Î†§Î≥¥ÏÑ∏Ïöî</div>
            <div id="tool-status">ÎèÑÍµ¨Î•º ÏÑ†ÌÉùÌïòÏó¨ Î∂ÑÏÑùÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî</div>
        </div>
    </div>

    <script>
        // Ï†ÑÏó≠ Î≥ÄÏàòÎì§
        const chartDiv = document.getElementById('chartDiv');
        const sidebar = document.getElementById('sidebar');
        const analysisResult = JSON.parse(localStorage.getItem('analysisResult'));
        const chartData = analysisResult ? analysisResult.chart_data : null;
        
        let layout, data;
        let isAIVisible = true;
        let isSidebarVisible = true;
        let magnetEnabled = true;
        let currentTool = null;
        let drawingIdCounter = 0;
        
        // ÌîºÎ≥¥ÎÇòÏπò Î†àÎ≤® Î∞è ÏÉâÏÉÅ
        const fiboLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
        const fiboColors = ['#787878', '#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#FFD700'];

        function initializeApp() {
            if (!chartData) {
                chartDiv.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #e74c3c;">
                        <div style="text-align: center;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 20px;"></i>
                            <h3>Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§</h3>
                            <p>Î©îÏù∏ ÌéòÏù¥ÏßÄÏóêÏÑú Î®ºÏ†Ä Î∂ÑÏÑùÏùÑ Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.</p>
                        </div>
                    </div>
                `;
                return;
            }

            setupPerformanceDashboard();
            drawChart();
            attachEventListeners();
        }

        function setupPerformanceDashboard() {
            // ÌÉÄÏù¥ÌãÄ ÏóÖÎç∞Ïù¥Ìä∏
            document.getElementById('chartTitle').textContent = 
                `${analysisResult.symbol} AI Í±∞Îûò Î∂ÑÏÑù (${analysisResult.period})`;
            
            // AI Ï∂îÏ≤ú ÌëúÏãú
            if (analysisResult.todays_action) {
                const recommendation = document.getElementById('aiRecommendation');
                const recommendationText = document.getElementById('recommendationText');
                
                recommendationText.textContent = `Ïò§ÎäòÏùò AI Ï∂îÏ≤ú: ${analysisResult.todays_action}`;
                recommendation.style.display = 'flex';
                
                // Ï∂îÏ≤úÏóê Îî∞Îùº ÏÉâÏÉÅ Î≥ÄÍ≤Ω
                const actionColors = {
                    'Í∞ïÎ†•Îß§Ïàò': 'linear-gradient(45deg, #27ae60, #2ecc71)',
                    'Îß§Ïàò': 'linear-gradient(45deg, #3498db, #2980b9)',
                    'Î≥¥Ïú†': 'linear-gradient(45deg, #f39c12, #e67e22)',
                    'Îß§ÎèÑ': 'linear-gradient(45deg, #e74c3c, #c0392b)',
                    'Í∞ïÎ†•Îß§ÎèÑ': 'linear-gradient(45deg, #8e44ad, #9b59b6)'
                };
                
                recommendation.style.background = actionColors[analysisResult.todays_action] || 
                    'linear-gradient(45deg, #95a5a6, #7f8c8d)';
            }

            // ÏÑ±Í≥º ÏßÄÌëú Ïπ¥ÎìúÎì§ ÏÉùÏÑ±
            createMetricCards();
            
            // Í±∞Îûò ÎÇ¥Ïó≠ ÌëúÏãú
            displayTradeHistory();
        }

        function createMetricCards() {
            const metricsGrid = document.getElementById('metricsGrid');
            const metrics = [
                {
                    label: 'Ï¥ù ÏàòÏùµÎ•†',
                    value: `${(analysisResult.total_return * 100).toFixed(2)}%`,
                    className: analysisResult.total_return >= 0 ? 'positive' : 'negative'
                },
                {
                    label: 'Î≤§ÏπòÎßàÌÅ¨ ÎåÄÎπÑ',
                    value: `${((analysisResult.total_return - analysisResult.benchmark_return) * 100).toFixed(2)}%`,
                    className: (analysisResult.total_return - analysisResult.benchmark_return) >= 0 ? 'positive' : 'negative'
                },
                {
                    label: 'Ï¥ù Í±∞ÎûòÌöüÏàò',
                    value: analysisResult.total_trades,
                    className: 'neutral'
                },
                {
                    label: 'ÏäπÎ•†',
                    value: analysisResult.win_rate ? `${(analysisResult.win_rate * 100).toFixed(1)}%` : 'N/A',
                    className: analysisResult.win_rate > 0.5 ? 'positive' : 'negative'
                },
                {
                    label: 'ÏµúÎåÄ ÎÇôÌè≠',
                    value: analysisResult.max_drawdown ? `${(analysisResult.max_drawdown * 100).toFixed(2)}%` : 'N/A',
                    className: 'negative'
                },
                {
                    label: 'ÏÉ§ÌîÑ ÎπÑÏú®',
                    value: analysisResult.sharpe_ratio ? analysisResult.sharpe_ratio.toFixed(3) : 'N/A',
                    className: analysisResult.sharpe_ratio > 1 ? 'positive' : 'neutral'
                }
            ];

            metricsGrid.innerHTML = metrics.map(metric => `
                <div class="metric-card">
                    <div class="metric-value ${metric.className}">${metric.value}</div>
                    <div class="metric-label">${metric.label}</div>
                </div>
            `).join('');
        }

        function displayTradeHistory() {
            const tradesContainer = document.getElementById('tradesContainer');
            
            if (!chartData.trades || chartData.trades.length === 0) {
                tradesContainer.innerHTML = `
                    <div style="text-align: center; color: #6c757d; padding: 20px;">
                        <i class="fas fa-info-circle"></i>
                        <p>Í±∞Îûò ÎÇ¥Ïó≠Ïù¥ ÏóÜÏäµÎãàÎã§</p>
                    </div>
                `;
                return;
            }

            // ÏµúÏã† Í±∞Îûò 10Í∞úÎßå ÌëúÏãú
            const recentTrades = chartData.trades.slice(-10).reverse();
            
            tradesContainer.innerHTML = recentTrades.map(trade => `
                <div class="trade-item trade-${trade.type}">
                    <div class="trade-date">${trade.date}</div>
                    <div class="trade-details">
                        <span class="trade-type ${trade.type === 'buy' ? 'positive' : 'negative'}">
                            ${trade.type === 'buy' ? 'Îß§Ïàò' : 'Îß§ÎèÑ'}
                        </span>
                        <span class="trade-price">${trade.price.toFixed(2)}</span>
                    </div>
                </div>
            `).join('');
        }

        function drawChart() {
            // Ï∫îÎì§Ïä§Ìã± Ï∞®Ìä∏
            const candlestickTrace = {
                x: chartData.dates,
                open: chartData.open,
                high: chartData.high,
                low: chartData.low,
                close: chartData.close,
                type: 'candlestick',
                name: 'Ï£ºÍ∞Ä',
                xaxis: 'x',
                yaxis: 'y1'
            };

            // AI Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÑ±Í≥º
            const portfolioTrace = {
                x: chartData.dates,
                y: chartData.portfolio,
                type: 'scatter',
                mode: 'lines',
                name: 'AI Ï†ÑÎûµ',
                line: { color: '#667eea', width: 3 },
                xaxis: 'x',
                yaxis: 'y2'
            };

            // Î≤§ÏπòÎßàÌÅ¨ (Îß§Ïàò ÌõÑ Î≥¥Ïú†)
            const benchmarkTrace = {
                x: chartData.dates,
                y: chartData.benchmark,
                type: 'scatter',
                mode: 'lines',
                name: 'Îß§ÏàòÌõÑÎ≥¥Ïú†',
                line: { color: '#f5a623', width: 2, dash: 'dash' },
                xaxis: 'x',
                yaxis: 'y2'
            };

            layout = {
                title: {
                    text: `${analysisResult.symbol} ÏÉÅÏÑ∏ Î∂ÑÏÑù Í≤∞Í≥º`,
                    font: { size: 18, color: '#2c3e50' }
                },
                xaxis: {
                    domain: [0, 1],
                    anchor: 'y2',
                    rangeslider: { visible: false },
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                yaxis: {
                    domain: [0.35, 1],
                    title: 'Ï£ºÍ∞Ä ($)',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                yaxis2: {
                    domain: [0, 0.3],
                    title: 'Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò ($)',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                shapes: [],
                annotations: [],
                dragmode: 'pan',
                plot_bgcolor: 'rgba(255,255,255,0.9)',
                paper_bgcolor: 'rgba(255,255,255,0.9)',
                margin: { t: 50, b: 50, l: 60, r: 60 },
                legend: {
                    orientation: 'h',
                    x: 0,
                    y: 1.02,
                    bgcolor: 'rgba(255,255,255,0.8)'
                }
            };

            // Í±∞Îûò ÎßàÏª§ Ï∂îÍ∞Ä
            if (chartData.trades) {
                chartData.trades.forEach(trade => {
                    layout.annotations.push({
                        name: 'trade_marker',
                        x: trade.date,
                        y: trade.price,
                        xref: 'x',
                        yref: 'y1',
                        showarrow: true,
                        arrowhead: trade.type === 'buy' ? 6 : 5,
                        ax: 0,
                        ay: trade.type === 'buy' ? -30 : 30,
                        bordercolor: trade.type === 'buy' ? '#27ae60' : '#e74c3c',
                        bgcolor: trade.type === 'buy' ? 'rgba(46, 204, 113, 0.8)' : 'rgba(231, 76, 60, 0.8)',
                        text: trade.type === 'buy' ? 'B' : 'S',
                        font: { color: 'white', size: 10 }
                    });
                });
            }

            data = [candlestickTrace, portfolioTrace, benchmarkTrace];
            
            Plotly.newPlot('chartDiv', data, layout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['select2d', 'lasso2d', 'autoScale2d'],
                modeBarButtonsToAdd: [{
                    name: 'Reset view',
                    icon: Plotly.Icons.home,
                    click: function() {
                        Plotly.relayout('chartDiv', {
                            'xaxis.autorange': true,
                            'yaxis.autorange': true,
                            'yaxis2.autorange': true
                        });
                    }
                }]
            });
        }

        function attachEventListeners() {
            // UI Î≤ÑÌäºÎì§
            const magnetBtn = document.getElementById('magnetBtn');
            const undoBtn = document.getElementById('undoBtn');
            const clearBtn = document.getElementById('clearBtn');
            const toggleAIBtn = document.getElementById('toggleAIBtn');
            const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
            const rangeButtons = document.querySelectorAll('.range-btn');
            const toolButtons = document.querySelectorAll('.tool-btn');

            // ÏûêÏÑù Í∏∞Îä• ÌÜ†Í∏Ä
            magnetBtn.addEventListener('click', () => {
                magnetEnabled = !magnetEnabled;
                magnetBtn.classList.toggle('active', magnetEnabled);
                updateStatus();
            });

            // AI Î∂ÑÏÑù ÌëúÏãú/Ïà®ÍπÄ
            toggleAIBtn.addEventListener('click', () => {
                isAIVisible = !isAIVisible;
                toggleAIBtn.classList.toggle('active', isAIVisible);
                
                // Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ÏôÄ Î≤§ÏπòÎßàÌÅ¨ ÎùºÏù∏ ÌÜ†Í∏Ä
                Plotly.restyle('chartDiv', { visible: isAIVisible }, [1, 2]);
                
                // Í±∞Îûò ÎßàÏª§ ÌÜ†Í∏Ä
                const annotationUpdates = {};
                layout.annotations.forEach((ann, i) => {
                    if (ann.name === 'trade_marker') {
                        annotationUpdates[`annotations[${i}].visible`] = isAIVisible;
                    }
                });
                if (Object.keys(annotationUpdates).length > 0) {
                    Plotly.relayout('chartDiv', annotationUpdates);
                }
            });

            // ÏÇ¨Ïù¥ÎìúÎ∞î ÌÜ†Í∏Ä
            toggleSidebarBtn.addEventListener('click', () => {
                isSidebarVisible = !isSidebarVisible;
                toggleSidebarBtn.classList.toggle('active', isSidebarVisible);
                sidebar.style.display = isSidebarVisible ? 'block' : 'none';
            });

            // Í∏∞Í∞Ñ ÏÑ†ÌÉù Î≤ÑÌäºÎì§
            rangeButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    rangeButtons.forEach(b => b.classList.remove('active'));
                    e.currentTarget.classList.add('active');
                    
                    const range = e.currentTarget.dataset.range;
                    const endDate = new Date(chartData.dates[chartData.dates.length - 1]);
                    let startDate = new Date(chartData.dates[0]);
                    
                    if (range !== 'all') {
                        startDate = new Date(endDate);
                        if (range === '1m') startDate.setMonth(startDate.getMonth() - 1);
                        else if (range === '3m') startDate.setMonth(startDate.getMonth() - 3);
                        else if (range === '6m') startDate.setMonth(startDate.getMonth() - 6);
                        else if (range === '1y') startDate.setFullYear(startDate.getFullYear() - 1);
                    }
                    
                    Plotly.relayout('chartDiv', {
                        'xaxis.range': [startDate.toISOString().split('T')[0], endDate.toISOString().split('T')[0]]
                    });
                });
            });

            // Í∑∏Î¶¨Í∏∞ ÎèÑÍµ¨Îì§
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const toolName = btn.id.split('-').slice(1).join('-');
                    setActiveTool(toolName);
                });
            });

            // ÏßÄÏö∞Í∏∞ Î∞è ÎêòÎèåÎ¶¨Í∏∞
            clearBtn.addEventListener('click', () => {
                layout.shapes = layout.shapes.filter(s => s.drawing_id === undefined);
                layout.annotations = layout.annotations.filter(a => 
                    a.drawing_id === undefined && a.name !== 'trade_marker'
                );
                Plotly.react('chartDiv', data, layout);
            });

            undoBtn.addEventListener('click', () => {
                const lastDrawingIdNum = Math.max(0, 
                    ...layout.shapes.map(s => parseInt(s.drawing_id?.split('-')[1] || 0)),
                    ...layout.annotations.map(a => parseInt(a.drawing_id?.split('-')[1] || 0))
                );
                
                if (lastDrawingIdNum > 0) {
                    const drawingId = `drawing-${lastDrawingIdNum}`;
                    layout.shapes = layout.shapes.filter(s => s.drawing_id !== drawingId);
                    layout.annotations = layout.annotations.filter(a => s.drawing_id !== drawingId);
                } else if (layout.shapes.length > 0) {
                    layout.shapes.pop();
                }
                
                Plotly.react('chartDiv', data, layout);
            });

            // Plotly Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎì§
            setupPlotlyEvents();
        }

        function setupPlotlyEvents() {
            // Ï∞®Ìä∏ Ìò∏Î≤Ñ Ïù¥Î≤§Ìä∏
            chartDiv.on('plotly_hover', (eventData) => {
                const point = eventData.points[0];
                let priceText = '';
                
                if (point.close !== undefined) {
                    priceText = `O:${point.open.toFixed(2)} H:${point.high.toFixed(2)} L:${point.low.toFixed(2)} C:${point.close.toFixed(2)}`;
                } else if (point.y !== undefined) {
                    priceText = point.y.toFixed(2);
                }
                
                document.getElementById('coordinates').innerHTML = `
                    <strong>ÎÇ†Ïßú:</strong> ${point.x} | <strong>Í∞ÄÍ≤©:</strong> ${priceText}
                    ${magnetEnabled ? ' | <span style="color: #27ae60;">üß≤ ÏûêÏÑù ON</span>' : ' | <span style="color: #95a5a6;">ÏûêÏÑù OFF</span>'}
                `;
            });

            chartDiv.on('plotly_unhover', () => {
                document.getElementById('coordinates').innerHTML = `
                    ÎßàÏö∞Ïä§Î•º Ï∞®Ìä∏Ïóê Ïò¨Î†§Î≥¥ÏÑ∏Ïöî 
                    ${magnetEnabled ? ' | <span style="color: #27ae60;">üß≤ ÏûêÏÑù ON</span>' : ' | <span style="color: #95a5a6;">ÏûêÏÑù OFF</span>'}
                `;
            });

            // Í∑∏Î¶¨Í∏∞ Ïù¥Î≤§Ìä∏ (Í∏∞Ï°¥Í≥º ÎèôÏùºÌïú Î°úÏßÅ)
            chartDiv.on('plotly_relayout', handleDrawingEvents);
        }

        function handleDrawingEvents(eventData) {
            // Í∑∏Î¶¨Í∏∞ ÎèÑÍµ¨ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ Î°úÏßÅ
            if (currentTool && (eventData['shapes[0].x0'] !== undefined || 
                (eventData.shapes && eventData.shapes.length > layout.shapes.length))) {
                
                const drawingId = `drawing-${drawingIdCounter++}`;
                const lastShape = layout.shapes[layout.shapes.length - 1];
                
                if (lastShape && magnetEnabled) {
                    // ÏûêÏÑù Í∏∞Îä• Ï†ÅÏö©
                    const snappedStart = findNearestCandlePoint(lastShape.x0, lastShape.y0);
                    const snappedEnd = findNearestCandlePoint(lastShape.x1, lastShape.y1);
                    
                    lastShape.x0 = snappedStart.x;
                    lastShape.y0 = snappedStart.y;
                    lastShape.x1 = snappedEnd.x;
                    lastShape.y1 = snappedEnd.y;
                }
                
                if (lastShape) {
                    lastShape.drawing_id = drawingId;
                    lastShape.editable = true;
                    
                    // ÎèÑÍµ¨Î≥Ñ Ïä§ÌÉÄÏùº Ï†ÅÏö©
                    switch(currentTool) {
                        case 'trendline':
                            lastShape.name = 'trendline';
                            lastShape.line = { color: '#0066cc', width: 2 };
                            break;
                        case 'horizontal':
                            lastShape.name = 'horizontal';
                            lastShape.y1 = lastShape.y0;
                            lastShape.line = { color: '#ff6b6b', width: 2 };
                            break;
                        case 'fibonacci':
                            lastShape.name = 'fib_bg';
                            lastShape.fillcolor = 'rgba(102, 126, 234, 0.1)';
                            lastShape.line = { width: 0 };
                            createFibonacciLevels(lastShape, drawingId);
                            break;
                    }
                    
                    setActiveTool(currentTool); // ÎèÑÍµ¨ ÎπÑÌôúÏÑ±Ìôî
                    Plotly.react('chartDiv', data, layout);
                }
            }
            
            // Í∏∞Ï°¥ ÎèÑÌòï Ìé∏Ïßë Ïãú ÏûêÏÑù Ï†ÅÏö©
            else if (Object.keys(eventData).some(k => k.startsWith('shapes['))) {
                const shapeKey = Object.keys(eventData).find(k => k.startsWith('shapes['));
                const shapeIndex = parseInt(shapeKey.match(/\d+/)[0]);
                const editedShape = layout.shapes[shapeIndex];
                
                if (editedShape && editedShape.editable && magnetEnabled) {
                    const snappedStart = findNearestCandlePoint(editedShape.x0, editedShape.y0);
                    const snappedEnd = findNearestCandlePoint(editedShape.x1, editedShape.y1);
                    
                    editedShape.x0 = snappedStart.x;
                    editedShape.y0 = snappedStart.y;
                    editedShape.x1 = snappedEnd.x;
                    editedShape.y1 = snappedEnd.y;
                    
                    // ÌîºÎ≥¥ÎÇòÏπò ÏóÖÎç∞Ïù¥Ìä∏
                    if (editedShape.name === 'fib_bg') {
                        layout.shapes = layout.shapes.filter(s => 
                            s.drawing_id !== editedShape.drawing_id || s.name === editedShape.name
                        );
                        layout.annotations = layout.annotations.filter(a => 
                            a.drawing_id !== editedShape.drawing_id
                        );
                        createFibonacciLevels(editedShape, editedShape.drawing_id);
                    }
                    
                    Plotly.react('chartDiv', data, layout);
                }
            }
        }

        function findNearestCandlePoint(x, y) {
            if (!magnetEnabled || !chartData.dates) return { x, y, snapped: false };
            
            // Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎÇ†Ïßú Ï∞æÍ∏∞
            let closestDateIndex = 0;
            let minDistance = Infinity;
            
            chartData.dates.forEach((date, index) => {
                const distance = Math.abs(new Date(x).getTime() - new Date(date).getTime());
                if (distance < minDistance) {
                    minDistance = distance;
                    closestDateIndex = index;
                }
            });
            
            // OHLC Ìè¨Ïù∏Ìä∏ Ï∞æÍ∏∞
            const ohlcPrices = [
                chartData.open[closestDateIndex],
                chartData.high[closestDateIndex],
                chartData.low[closestDateIndex],
                chartData.close[closestDateIndex]
            ];
            
            let closestPrice = ohlcPrices[0];
            let minPriceDistance = Math.abs(closestPrice - y);
            
            ohlcPrices.forEach(price => {
                const distance = Math.abs(price - y);
                if (distance < minPriceDistance) {
                    minPriceDistance = distance;
                    closestPrice = price;
                }
            });
            
            return {
                x: chartData.dates[closestDateIndex],
                y: closestPrice,
                snapped: true
            };
        }

        function createFibonacciLevels(rect, drawingId) {
            const y_start = Math.min(rect.y0, rect.y1);
            const y_end = Math.max(rect.y0, rect.y1);
            const y_diff = y_end - y_start;
            const descending = rect.y0 > rect.y1;
            
            fiboLevels.forEach((level, i) => {
                const level_y = descending ? y_end - y_diff * level : y_start + y_diff * level;
                
                layout.shapes.push({
                    type: 'line',
                    x0: rect.x0,
                    y0: level_y,
                    x1: rect.x1,
                    y1: level_y,
                    line: { 
                        color: fiboColors[i % fiboColors.length], 
                        width: 1, 
                        dash: level === 0 || level === 1 ? 'solid' : 'dot' 
                    },
                    name: 'fib_line',
                    drawing_id: drawingId,
                    editable: false
                });
                
                layout.annotations.push({
                    x: rect.x1,
                    y: level_y,
                    text: `${(level * 100).toFixed(1)}% (${level_y.toFixed(2)})`,
                    showarrow: false,
                    font: { color: fiboColors[i % fiboColors.length], size: 10 },
                    xanchor: 'left',
                    yanchor: 'middle',
                    name: 'fib_annotation',
                    drawing_id: drawingId
                });
            });
        }

        function setActiveTool(toolName) {
            currentTool = (currentTool === toolName) ? null : toolName;
            
            const toolButtons = document.querySelectorAll('.tool-btn');
            toolButtons.forEach(btn => {
                btn.classList.toggle('active', btn.id === `tool-${currentTool}`);
            });
            
            let dragmode = 'pan';
            if (['trendline', 'horizontal'].includes(currentTool)) {
                dragmode = 'drawline';
            } else if (['fibonacci'].includes(currentTool)) {
                dragmode = 'drawrect';
            }
            
            layout.dragmode = dragmode;
            Plotly.relayout('chartDiv', { dragmode: dragmode });
            
            updateStatus();
        }

        function updateStatus() {
            const statusElement = document.getElementById('tool-status');
            const magnetStatus = magnetEnabled ? ' (ÏûêÏÑù ON)' : ' (ÏûêÏÑù OFF)';
            
            const messages = {
                null: 'ÎèÑÍµ¨Î•º ÏÑ†ÌÉùÌïòÏó¨ Î∂ÑÏÑùÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî' + magnetStatus,
                'trendline': 'Ï∂îÏÑ∏ÏÑ†ÏùÑ Í∑∏ÏúºÏÑ∏Ïöî' + magnetStatus,
                'horizontal': 'ÏàòÌèâÏÑ†ÏùÑ Í∑∏ÏúºÏÑ∏Ïöî' + magnetStatus,
                'fibonacci': 'ÌîºÎ≥¥ÎÇòÏπò ÏòÅÏó≠ÏùÑ ÎìúÎûòÍ∑∏ÌïòÏÑ∏Ïöî' + magnetStatus
            };
            
            statusElement.textContent = messages[currentTool] || messages.null;
        }

        // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        document.getElementById('undoBtn').click();
                        break;
                    case 'm':
                        e.preventDefault();
                        document.getElementById('magnetBtn').click();
                        break;
                }
            }
            
            if (e.key === 'Escape') {
                setActiveTool(null);
            }
        });

        // Î∞òÏùëÌòï Ï≤òÎ¶¨
        function handleResize() {
            Plotly.Plots.resize(chartDiv);
        }

        window.addEventListener('resize', handleResize);

        // Ïï± Ï¥àÍ∏∞Ìôî
        initializeApp();
    </script>
</body>
</html><!-- chart.html - Í∞úÏÑ†Îêú Ï∞®Ìä∏ ÏãúÍ∞ÅÌôî ÌéòÏù¥ÏßÄ
Ï£ºÏöî Í∞úÏÑ†ÏÇ¨Ìï≠:
1. ÏÑ±Í≥º ÏßÄÌëú ÎåÄÏãúÎ≥¥Îìú Ï∂îÍ∞Ä (ÏäπÎ•†, ÏÉ§ÌîÑ ÎπÑÏú®, ÏµúÎåÄ ÎÇôÌè≠ Îì±)
2. Í±∞Îûò ÎÇ¥Ïó≠ ÏÉÅÏÑ∏ ÌëúÏãú
3. AI Ï∂îÏ≤ú Ïï°ÏÖò Í∞ïÏ°∞ ÌëúÏãú
4. Í∞úÏÑ†Îêú ÏûêÏÑù Í∏∞Îä• (5Îã®Í≥Ñ Ïï°ÏÖò ÎåÄÏùë)
5. Î∞òÏùëÌòï Î†àÏù¥ÏïÑÏõÉ Î∞è Ìñ•ÏÉÅÎêú UI/UX
-->

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Ï£ºÏãù Í±∞Îûò Î∂ÑÏÑù - Í≥†Í∏â Ï∞®Ìä∏</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100vh; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow-x: hidden;
        }
        .container { 
            width: 100%; min-height: 100vh; 
            display: flex; flex-direction: column; 
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
        }
        .header { 
            padding: 15px 20px; 
            backgroun
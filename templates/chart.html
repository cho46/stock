<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê³ ê¸‰ ì°¨íŠ¸ ë¶„ì„ ë„êµ¬ (ìì„ ê¸°ëŠ¥)</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        .container {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
        }
        .header {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
        }
        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .tool-group {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .btn {
            padding: 10px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: rgba(255,255,255,0.9);
            color: #2c3e50;
            border: 1px solid rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        .btn:hover {
            background: rgba(255,255,255,1);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        .btn.magnet {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            position: relative;
        }
        .btn.magnet::after {
            content: '';
            position: absolute;
            top: 2px; right: 2px;
            width: 8px; height: 8px;
            background: #f39c12;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .btn.danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }
        #chartDiv {
            flex-grow: 1;
            background: rgba(255,255,255,0.95);
            margin: 10px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .status-bar {
            padding: 8px 20px;
            background: rgba(255,255,255,0.9);
            border-top: 1px solid rgba(0,0,0,0.1);
            font-size: 0.85rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .magnet-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid #e74c3c;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.2);
            pointer-events: none;
            z-index: 1000;
            display: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">ê³ ê¸‰ ì°¨íŠ¸ ë¶„ì„ ë„êµ¬</h1>
            <div class="toolbar">
                <div class="tool-group">
                    <button id="magnetBtn" class="btn magnet active" title="ìì„ ê¸°ëŠ¥ (ìº”ë“¤ì— ìë™ ë¶™ê¸°)">
                        <i class="fas fa-magnet"></i> ìì„
                    </button>
                </div>

                <div class="tool-group">
                    <button id="tool-trendline" class="btn tool-btn" title="ì¶”ì„¸ì„ "><i class="fas fa-chart-line"></i> ì¶”ì„¸ì„ </button>
                    <button id="tool-horizontal" class="btn tool-btn" title="ìˆ˜í‰ì„ "><i class="fas fa-minus"></i> ìˆ˜í‰ì„ </button>
                    <button id="tool-vertical" class="btn tool-btn" title="ìˆ˜ì§ì„ "><i class="fas fa-grip-lines-vertical"></i> ìˆ˜ì§ì„ </button>
                </div>

                <div class="tool-group">
                    <button id="tool-fibonacci" class="btn tool-btn" title="í”¼ë³´ë‚˜ì¹˜ ë˜ëŒë¦¼"><i class="fas fa-wave-square"></i> í”¼ë³´ë‚˜ì¹˜</button>
                    <button id="tool-fibonacci-ext" class="btn tool-btn" title="í”¼ë³´ë‚˜ì¹˜ í™•ì¥"><i class="fas fa-expand-arrows-alt"></i> í”¼ë³´ í™•ì¥</button>
                </div>

                <div class="tool-group">
                    <button id="tool-rectangle" class="btn tool-btn" title="ì‚¬ê°í˜•"><i class="fas fa-square"></i> ì‚¬ê°í˜•</button>
                    <button id="tool-channel" class="btn tool-btn" title="ì±„ë„"><i class="fas fa-arrows-alt-v"></i> ì±„ë„</button>
                </div>

                <div class="tool-group">
                    <button id="tool-text" class="btn tool-btn" title="í…ìŠ¤íŠ¸"><i class="fas fa-font"></i> í…ìŠ¤íŠ¸</button>
                    <button id="tool-arrow" class="btn tool-btn" title="í™”ì‚´í‘œ"><i class="fas fa-arrow-right"></i> í™”ì‚´í‘œ</button>
                </div>

                <div class="tool-group">
                    <button id="undoBtn" class="btn" title="ë˜ëŒë¦¬ê¸°"><i class="fas fa-undo"></i> ë˜ëŒë¦¬ê¸°</button>
                    <button id="clearBtn" class="btn danger" title="ëª¨ë‘ ì§€ìš°ê¸°"><i class="fas fa-trash"></i> ì§€ìš°ê¸°</button>
                </div>
            </div>
        </div>

        <div id="chartDiv"></div>

        <div class="status-bar">
            <div id="coordinates">ë§ˆìš°ìŠ¤ë¥¼ ì°¨íŠ¸ì— ì˜¬ë ¤ë³´ì„¸ìš”</div>
            <div id="tool-status">ë„êµ¬ë¥¼ ì„ íƒí•˜ì—¬ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”</div>
        </div>
    </div>

    <div class="magnet-indicator" id="magnetIndicator"></div>

    <script>
        // ìƒ˜í”Œ ë°ì´í„° ìƒì„±
        function generateSampleData() {
            const dates = [];
            const open = [], high = [], low = [], close = [];
            const portfolio = [], benchmark = [];

            let basePrice = 100;
            let portfolioValue = 100;
            let benchmarkValue = 100;

            for (let i = 0; i < 200; i++) {
                const date = new Date(2023, 0, 1);
                date.setDate(date.getDate() + i);
                dates.push(date.toISOString().split('T')[0]);

                const change = (Math.random() - 0.5) * 6;
                const openPrice = basePrice;
                const closePrice = basePrice + change;
                const highPrice = Math.max(openPrice, closePrice) + Math.random() * 3;
                const lowPrice = Math.min(openPrice, closePrice) - Math.random() * 3;

                open.push(openPrice);
                high.push(highPrice);
                low.push(lowPrice);
                close.push(closePrice);

                basePrice = closePrice;

                const aiReturn = change * (1 + Math.random() * 0.3);
                const bhReturn = change;

                portfolioValue *= (1 + aiReturn / 100);
                benchmarkValue *= (1 + bhReturn / 100);

                portfolio.push(portfolioValue);
                benchmark.push(benchmarkValue);
            }

            return { dates, open, high, low, close, portfolio, benchmark };
        }

        const chartDiv = document.getElementById('chartDiv');
        const chartData = generateSampleData();

        // ì°¨íŠ¸ ë°ì´í„° ì„¤ì •
        const candlestickTrace = {
            x: chartData.dates,
            open: chartData.open,
            high: chartData.high,
            low: chartData.low,
            close: chartData.close,
            type: 'candlestick',
            name: 'ì£¼ê°€',
            xaxis: 'x',
            yaxis: 'y1'
        };

        const portfolioTrace = {
            x: chartData.dates,
            y: chartData.portfolio,
            type: 'scatter',
            mode: 'lines',
            name: 'AI ì „ëµ',
            line: { color: '#667eea', width: 2 },
            xaxis: 'x',
            yaxis: 'y2'
        };

        const benchmarkTrace = {
            x: chartData.dates,
            y: chartData.benchmark,
            type: 'scatter',
            mode: 'lines',
            name: 'ë²¤ì¹˜ë§ˆí¬',
            line: { color: '#f5a623', width: 2 },
            xaxis: 'x',
            yaxis: 'y2'
        };

        const layout = {
            title: {
                text: 'ê³ ê¸‰ ê¸°ìˆ ì  ë¶„ì„ (ìì„ ê¸°ëŠ¥)',
                font: { size: 20, color: '#2c3e50' }
            },
            xaxis: {
                domain: [0, 1],
                anchor: 'y2',
                rangeslider: { visible: false },
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)'
            },
            yaxis: {
                domain: [0.3, 1],
                title: 'ì£¼ê°€',
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)'
            },
            yaxis2: {
                domain: [0, 0.25],
                title: 'í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜',
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)'
            },
            shapes: [],
            annotations: [],
            dragmode: 'zoom',
            plot_bgcolor: 'rgba(255,255,255,0.9)',
            paper_bgcolor: 'rgba(255,255,255,0.9)',
            margin: { t: 50, b: 50, l: 60, r: 60 }
        };

        const data = [candlestickTrace, portfolioTrace, benchmarkTrace];

        // ì°¨íŠ¸ ìƒì„±
        Plotly.newPlot('chartDiv', data, layout, {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d']
        });

        // ìì„ ê¸°ëŠ¥ ë³€ìˆ˜ë“¤
        let magnetEnabled = true;
        const magnetThreshold = 15;
        const magnetBtn = document.getElementById('magnetBtn');
        const magnetIndicator = document.getElementById('magnetIndicator');

        // ë¶„ì„ ë„êµ¬ ì‹œìŠ¤í…œ
        let currentTool = null;
        let drawingIdCounter = 0;

        const toolButtons = document.querySelectorAll('.tool-btn');
        const undoBtn = document.getElementById('undoBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusElement = document.getElementById('tool-status');
        const coordinatesElement = document.getElementById('coordinates');

        // í”¼ë³´ë‚˜ì¹˜ ë ˆë²¨ ì„¤ì •
        const fiboLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
        const fiboExtLevels = [1, 1.236, 1.382, 1.5, 1.618, 2, 2.618];
        const fiboColors = ['#787878', '#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#FFD700'];

        // ìì„ ê¸°ëŠ¥ í† ê¸€
        magnetBtn.addEventListener('click', () => {
            magnetEnabled = !magnetEnabled;
            magnetBtn.classList.toggle('magnet', magnetEnabled);
            magnetBtn.classList.toggle('active', magnetEnabled);

            if (!magnetEnabled) {
                magnetIndicator.style.display = 'none';
            }

            updateStatus();
        });

        // ê°€ì¥ ê°€ê¹Œìš´ ìº”ë“¤ ë°ì´í„° í¬ì¸íŠ¸ ì°¾ê¸°
        function findNearestCandlePoint(x, y) {
            if (!magnetEnabled) return { x, y, snapped: false };

            // x ì¢Œí‘œì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë‚ ì§œ ì¸ë±ìŠ¤ ì°¾ê¸°
            let closestDateIndex = 0;
            let minDistance = Infinity;

            chartData.dates.forEach((date, index) => {
                const distance = Math.abs(new Date(x).getTime() - new Date(date).getTime());
                if (distance < minDistance) {
                    minDistance = distance;
                    closestDateIndex = index;
                }
            });

            // í•´ë‹¹ ë‚ ì§œì˜ OHLC ê°’ë“¤
            const ohlcPoints = [
                { price: chartData.open[closestDateIndex], type: 'Open' },
                { price: chartData.high[closestDateIndex], type: 'High' },
                { price: chartData.low[closestDateIndex], type: 'Low' },
                { price: chartData.close[closestDateIndex], type: 'Close' }
            ];

            // y ì¢Œí‘œì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ OHLC í¬ì¸íŠ¸ ì°¾ê¸°
            let closestPoint = ohlcPoints[0];
            let minYDistance = Math.abs(ohlcPoints[0].price - y);

            ohlcPoints.forEach(point => {
                const distance = Math.abs(point.price - y);
                if (distance < minYDistance) {
                    minYDistance = distance;
                    closestPoint = point;
                }
            });

            return {
                x: chartData.dates[closestDateIndex],
                y: closestPoint.price,
                snapped: true,
                type: closestPoint.type
            };
        }

        function setActiveTool(toolName) {
            currentTool = (currentTool === toolName) ? null : toolName;

            toolButtons.forEach(btn => {
                btn.classList.toggle('active', btn.id === `tool-${currentTool}`);
            });

            let dragmode = 'zoom';
            if (['trendline', 'horizontal', 'vertical', 'arrow'].includes(currentTool)) {
                dragmode = 'drawline';
            } else if (['rectangle', 'fibonacci', 'fibonacci-ext', 'channel'].includes(currentTool)) {
                dragmode = 'drawrect';
            }

            layout.dragmode = dragmode;
            Plotly.relayout('chartDiv', { dragmode: dragmode });

            updateStatus();
        }

        function updateStatus() {
            const magnetStatus = magnetEnabled ? ' (ğŸ§² ìì„ ON)' : ' (ìì„ OFF)';
            const messages = {
                null: 'ë„êµ¬ë¥¼ ì„ íƒí•˜ì—¬ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”' + magnetStatus,
                'trendline': 'ë‘ ì ì„ í´ë¦­í•˜ì—¬ ì¶”ì„¸ì„ ì„ ê·¸ìœ¼ì„¸ìš”' + magnetStatus,
                'horizontal': 'ìˆ˜í‰ì„ ì„ ê·¸ì„ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”' + magnetStatus,
                'vertical': 'ìˆ˜ì§ì„ ì„ ê·¸ì„ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”' + magnetStatus,
                'fibonacci': 'ë“œë˜ê·¸í•˜ì—¬ í”¼ë³´ë‚˜ì¹˜ ë˜ëŒë¦¼ ì˜ì—­ì„ ì„¤ì •í•˜ì„¸ìš”' + magnetStatus,
                'fibonacci-ext': 'ë“œë˜ê·¸í•˜ì—¬ í”¼ë³´ë‚˜ì¹˜ í™•ì¥ ì˜ì—­ì„ ì„¤ì •í•˜ì„¸ìš”' + magnetStatus,
                'rectangle': 'ë“œë˜ê·¸í•˜ì—¬ ì‚¬ê°í˜•ì„ ê·¸ìœ¼ì„¸ìš”' + magnetStatus,
                'channel': 'ë“œë˜ê·¸í•˜ì—¬ ì±„ë„ì„ ì„¤ì •í•˜ì„¸ìš”' + magnetStatus,
                'text': 'í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•  ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”' + magnetStatus,
                'arrow': 'ë“œë˜ê·¸í•˜ì—¬ í™”ì‚´í‘œë¥¼ ê·¸ìœ¼ì„¸ìš”' + magnetStatus
            };
            statusElement.textContent = messages[currentTool] || messages[null];
        }

        // ë„êµ¬ ë²„íŠ¼ ì´ë²¤íŠ¸
        toolButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const toolName = btn.id.split('-').slice(1).join('-');
                setActiveTool(toolName);
            });
        });

        // ì§€ìš°ê¸° ë° ë˜ëŒë¦¬ê¸°
        clearBtn.addEventListener('click', () => {
            layout.shapes = [];
            layout.annotations = [];
            Plotly.react('chartDiv', data, layout);
        });

        undoBtn.addEventListener('click', () => {
            if (layout.shapes.length > 0 || layout.annotations.length > 0) {
                const lastDrawingId = Math.max(
                    ...layout.shapes.filter(s => s.drawing_id).map(s => parseInt(s.drawing_id.split('-')[1]) || 0),
                    ...layout.annotations.filter(a => a.drawing_id).map(a => parseInt(a.drawing_id.split('-')[1]) || 0),
                    0
                );

                if (lastDrawingId > 0) {
                    const drawingId = `drawing-${lastDrawingId}`;
                    layout.shapes = layout.shapes.filter(s => s.drawing_id !== drawingId);
                    layout.annotations = layout.annotations.filter(a => a.drawing_id !== drawingId);
                } else {
                    if (layout.shapes.length > 0) layout.shapes.pop();
                    else if (layout.annotations.length > 0) layout.annotations.pop();
                }

                Plotly.react('chartDiv', data, layout);
            }
        });

        // í”¼ë³´ë‚˜ì¹˜ ë˜ëŒë¦¼ ê³„ì‚°
        function createFibonacciRetracement(rect, drawingId) {
            const y_start = Math.min(rect.y0, rect.y1);
            const y_end = Math.max(rect.y0, rect.y1);
            const y_diff = y_end - y_start;

            fiboLevels.forEach((level, i) => {
                const level_y = rect.y0 > rect.y1 ? y_end - y_diff * level : y_start + y_diff * level;

                layout.shapes.push({
                    type: 'line',
                    x0: rect.x0, y0: level_y, x1: rect.x1, y1: level_y,
                    line: { color: fiboColors[i], width: 1, dash: level === 0 || level === 1 ? 'solid' : 'dot' },
                    name: 'fib_line',
                    drawing_id: drawingId,
                    editable: false
                });

                layout.annotations.push({
                    x: rect.x1, y: level_y,
                    text: `${(level * 100).toFixed(1)}% (${level_y.toFixed(2)})`,
                    showarrow: false,
                    font: { color: fiboColors[i], size: 10 },
                    xanchor: 'left',
                    yanchor: 'middle',
                    name: 'fib_annotation',
                    drawing_id: drawingId
                });
            });
        }

        // í”¼ë³´ë‚˜ì¹˜ í™•ì¥ ê³„ì‚°
        function createFibonacciExtension(rect, drawingId) {
            const y_start = Math.min(rect.y0, rect.y1);
            const y_end = Math.max(rect.y0, rect.y1);
            const y_diff = y_end - y_start;

            fiboExtLevels.forEach((level, i) => {
                const level_y = rect.y0 > rect.y1 ? y_end - y_diff * level : y_start + y_diff * level;

                layout.shapes.push({
                    type: 'line',
                    x0: rect.x0, y0: level_y, x1: rect.x1, y1: level_y,
                    line: { color: fiboColors[i % fiboColors.length], width: 1, dash: 'dash' },
                    name: 'fib_ext_line',
                    drawing_id: drawingId,
                    editable: false
                });

                layout.annotations.push({
                    x: rect.x1, y: level_y,
                    text: `${(level * 100).toFixed(1)}% (${level_y.toFixed(2)})`,
                    showarrow: false,
                    font: { color: fiboColors[i % fiboColors.length], size: 10 },
                    xanchor: 'left',
                    yanchor: 'middle',
                    name: 'fib_ext_annotation',
                    drawing_id: drawingId
                });
            });
        }

        // ì±„ë„ ìƒì„±
        function createChannel(rect, drawingId) {
            const y_diff = rect.y1 - rect.y0;

            // ìƒë‹¨ ë¼ì¸
            layout.shapes.push({
                type: 'line',
                x0: rect.x0, y0: rect.y1, x1: rect.x1, y1: rect.y1,
                line: { color: '#0066cc', width: 2 },
                name: 'channel_top',
                drawing_id: drawingId,
                editable: true
            });

            // í•˜ë‹¨ ë¼ì¸
            layout.shapes.push({
                type: 'line',
                x0: rect.x0, y0: rect.y0, x1: rect.x1, y1: rect.y0,
                line: { color: '#0066cc', width: 2 },
                name: 'channel_bottom',
                drawing_id: drawingId,
                editable: true
            });

            // ì¤‘ì•™ ë¼ì¸
            const mid_y = rect.y0 + y_diff / 2;
            layout.shapes.push({
                type: 'line',
                x0: rect.x0, y0: mid_y, x1: rect.x1, y1: mid_y,
                name: 'channel_mid',
                drawing_id: drawingId,
                editable: false
            });
        }

        // ìì„ íš¨ê³¼ê°€ ì ìš©ëœ relayout ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        chartDiv.on('plotly_relayout', (eventData) => {
            // ìƒˆë¡œìš´ ë„í˜•ì´ ê·¸ë ¤ì§„ ê²½ìš°
            if (currentTool && (eventData['shapes[0].x0'] !== undefined ||
                (eventData.shapes && eventData.shapes.length > layout.shapes.length))) {

                const drawingId = `drawing-${drawingIdCounter++}`;
                const lastShape = layout.shapes[layout.shapes.length - 1];

                if (lastShape && magnetEnabled) {
                    // ìì„ ê¸°ëŠ¥ ì ìš© - ì‹œì‘ì ê³¼ ëì ì„ ìº”ë“¤ í¬ì¸íŠ¸ì— ìŠ¤ëƒ…
                    const snappedStart = findNearestCandlePoint(lastShape.x0, lastShape.y0);
                    const snappedEnd = findNearestCandlePoint(lastShape.x1, lastShape.y1);

                    lastShape.x0 = snappedStart.x;
                    lastShape.y0 = snappedStart.y;
                    lastShape.x1 = snappedEnd.x;
                    lastShape.y1 = snappedEnd.y;
                }

                if (lastShape) {
                    lastShape.drawing_id = drawingId;
                    lastShape.editable = true;

                    // ë„êµ¬ë³„ ì²˜ë¦¬
                    switch(currentTool) {
                        case 'trendline':
                            lastShape.name = 'trendline';
                            lastShape.line = { color: '#0066cc', width: 2 };
                            break;

                        case 'horizontal':
                            lastShape.name = 'horizontal';
                            lastShape.line = { color: '#ff6b6b', width: 2 };
                            // ìˆ˜í‰ì„ ì€ yê°’ë§Œ ìŠ¤ëƒ…
                            if (magnetEnabled) {
                                const snappedY = findNearestCandlePoint(lastShape.x0, lastShape.y0).y;
                                lastShape.y0 = snappedY;
                                lastShape.y1 = snappedY;
                            }
                            break;

                        case 'vertical':
                            lastShape.name = 'vertical';
                            lastShape.line = { color: '#4ecdc4', width: 2 };
                            // ìˆ˜ì§ì„ ì€ xê°’ë§Œ ìŠ¤ëƒ…
                            if (magnetEnabled) {
                                const snappedX = findNearestCandlePoint(lastShape.x0, lastShape.y0).x;
                                lastShape.x0 = snappedX;
                                lastShape.x1 = snappedX;
                            }
                            break;

                        case 'fibonacci':
                            lastShape.name = 'fib_bg';
                            lastShape.fillcolor = 'rgba(102, 126, 234, 0.1)';
                            lastShape.line = { width: 0 };
                            createFibonacciRetracement(lastShape, drawingId);
                            break;

                        case 'fibonacci-ext':
                            lastShape.name = 'fib_ext_bg';
                            lastShape.fillcolor = 'rgba(255, 107, 107, 0.1)';
                            lastShape.line = { width: 0 };
                            createFibonacciExtension(lastShape, drawingId);
                            break;

                        case 'rectangle':
                            lastShape.name = 'rectangle';
                            lastShape.line = { color: '#45b7d1', width: 2 };
                            lastShape.fillcolor = 'rgba(69, 183, 209, 0.1)';
                            break;

                        case 'channel':
                            lastShape.name = 'channel_bg';
                            lastShape.fillcolor = 'rgba(0, 102, 204, 0.05)';
                            lastShape.line = { width: 0 };
                            createChannel(lastShape, drawingId);
                            break;

                        case 'arrow':
                            lastShape.name = 'arrow';
                            lastShape.line = { color: '#e74c3c', width: 3 };
                            // í™”ì‚´í‘œ ë¨¸ë¦¬ ì¶”ê°€
                            layout.annotations.push({
                                x: lastShape.x1,
                                y: lastShape.y1,
                                text: 'â–¶',
                                showarrow: false,
                                font: { size: 16, color: '#e74c3c' },
                                name: 'arrow_head',
                                drawing_id: drawingId
                            });
                            break;
                    }

                    setActiveTool(currentTool); // ë„êµ¬ ë¹„í™œì„±í™”
                    Plotly.react('chartDiv', data, layout);
                }
            }

            // ê¸°ì¡´ ë„í˜•ì´ í¸ì§‘ëœ ê²½ìš°
            else if (Object.keys(eventData).some(k => k.startsWith('shapes['))) {
                const shapeKey = Object.keys(eventData).find(k => k.startsWith('shapes['));
                const shapeIndex = parseInt(shapeKey.match(/\d+/)[0]);
                const editedShape = layout.shapes[shapeIndex];

                if (editedShape) {
                    // í¸ì§‘ ì‹œì—ë„ ìì„ íš¨ê³¼ ì ìš©
                    if (magnetEnabled && editedShape.editable) {
                        const snappedStart = findNearestCandlePoint(editedShape.x0, editedShape.y0);
                        const snappedEnd = findNearestCandlePoint(editedShape.x1, editedShape.y1);

                        editedShape.x0 = snappedStart.x;
                        editedShape.y0 = snappedStart.y;
                        editedShape.x1 = snappedEnd.x;
                        editedShape.y1 = snappedEnd.y;
                    }

                    // í”¼ë³´ë‚˜ì¹˜ ê´€ë ¨ ë„í˜•ë“¤ì˜ ì—…ë°ì´íŠ¸
                    if (editedShape.name === 'fib_bg') {
                        layout.shapes = layout.shapes.filter(s =>
                            s.drawing_id !== editedShape.drawing_id || s.name === 'fib_bg'
                        );
                        layout.annotations = layout.annotations.filter(a =>
                            a.drawing_id !== editedShape.drawing_id
                        );
                        createFibonacciRetracement(editedShape, editedShape.drawing_id);

                        Plotly.relayout('chartDiv', {
                            shapes: layout.shapes,
                            annotations: layout.annotations
                        });
                    }
                    else if (editedShape.name === 'fib_ext_bg') {
                        layout.shapes = layout.shapes.filter(s =>
                            s.drawing_id !== editedShape.drawing_id || s.name === 'fib_ext_bg'
                        );
                        layout.annotations = layout.annotations.filter(a =>
                            a.drawing_id !== editedShape.drawing_id
                        );
                        createFibonacciExtension(editedShape, editedShape.drawing_id);

                        Plotly.relayout('chartDiv', {
                            shapes: layout.shapes,
                            annotations: layout.annotations
                        });
                    }
                }
            }
        });

        // ë§ˆìš°ìŠ¤ ì›€ì§ì„ê³¼ í´ë¦­ ì´ë²¤íŠ¸
        chartDiv.on('plotly_hover', (eventData) => {
            if (eventData.points && eventData.points.length > 0) {
                const point = eventData.points[0];
                let priceText = '';

                if (point.y !== undefined) {
                    priceText = point.y.toFixed(2);
                } else if (point.close !== undefined) {
                    priceText = `O:${point.open.toFixed(2)} H:${point.high.toFixed(2)} L:${point.low.toFixed(2)} C:${point.close.toFixed(2)}`;
                }

                coordinatesElement.innerHTML = `
                    <strong>ë‚ ì§œ:</strong> ${point.x} |
                    <strong>ê°€ê²©:</strong> ${priceText}
                    ${magnetEnabled ? ' | <span style="color: #27ae60;">ğŸ§² ìì„ ON</span>' : ' | <span style="color: #95a5a6;">ìì„ OFF</span>'}
                `;
            }
        });

        chartDiv.on('plotly_unhover', () => {
            coordinatesElement.innerHTML = `ë§ˆìš°ìŠ¤ë¥¼ ì°¨íŠ¸ì— ì˜¬ë ¤ë³´ì„¸ìš” ${magnetEnabled ? ' | <span style="color: #27ae60;">ğŸ§² ìì„ ON</span>' : ' | <span style="color: #95a5a6;">ìì„ OFF</span>'}`;
        });

        // í…ìŠ¤íŠ¸ ë„êµ¬ í´ë¦­ ì´ë²¤íŠ¸
        chartDiv.on('plotly_click', (eventData) => {
            if (currentTool === 'text' && eventData.points && eventData.points.length > 0) {
                let point = eventData.points[0];

                // ìì„ì´ í™œì„±í™”ëœ ê²½ìš° ìŠ¤ëƒ…
                if (magnetEnabled) {
                    const snapped = findNearestCandlePoint(point.x, point.y);
                    if (snapped.snapped) {
                        point = { x: snapped.x, y: snapped.y };
                    }
                }

                const text = prompt('ì¶”ê°€í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:', 'ë¶„ì„ ë©”ëª¨');

                if (text) {
                    const drawingId = `drawing-${drawingIdCounter++}`;
                    layout.annotations.push({
                        x: point.x,
                        y: point.y,
                        text: text,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 2,
                        arrowcolor: '#667eea',
                        font: {
                            size: 12,
                            color: '#2c3e50',
                            family: 'Arial Black'
                        },
                        bgcolor: 'rgba(255,255,255,0.8)',
                        bordercolor: '#667eea',
                        borderwidth: 2,
                        borderpad: 4,
                        name: 'text_annotation',
                        drawing_id: drawingId,
                        editable: true
                    });

                    setActiveTool(currentTool);
                    Plotly.react('chartDiv', data, layout);
                }
            }
        });

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        undoBtn.click();
                        break;
                    case 'm':
                        e.preventDefault();
                        magnetBtn.click();
                        break;
                }
            }

            // ESC í‚¤ë¡œ í˜„ì¬ ë„êµ¬ í•´ì œ
            if (e.key === 'Escape') {
                setActiveTool(null);
            }

            // ë„êµ¬ë³„ ë‹¨ì¶•í‚¤
            if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                switch(e.key) {
                    case '1': setActiveTool('trendline'); break;
                    case '2': setActiveTool('horizontal'); break;
                    case '3': setActiveTool('vertical'); break;
                    case '4': setActiveTool('fibonacci'); break;
                    case '5': setActiveTool('rectangle'); break;
                    case '6': setActiveTool('channel'); break;
                    case '7': setActiveTool('text'); break;
                    case '8': setActiveTool('arrow'); break;
                    case 'm': magnetBtn.click(); break;
                }
            }
        });

        // ì´ˆê¸° ìƒíƒœ ì„¤ì •
        updateStatus();

        // ì°¨íŠ¸ í¬ê¸° ì¡°ì • ì´ë²¤íŠ¸
        window.addEventListener('resize', () => {
            Plotly.Plots.resize(chartDiv);
        });


    </script>
</body>
</html>